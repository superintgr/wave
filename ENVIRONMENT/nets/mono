**Acknowledgement**
Constructor theory [language] is a meta-theory with its own physical principles that are intended to supplement and constrain dynamical theories, such as quantum theory and general relativity, which therefore we call subsidiary theories, [8]. Every subsidiary theory that is constructor-theory compliant must provide a set of allowed states of the allowed substrates, endowed with a topology.

An attribute x is a set of states all having a property x. For instance, in quantum theory, the set of all quantum states of a qubit where a given projector Π is sharp with value 1 is an attribute. A variable is a set of disjoint attributes, where 'disjoint' has to be intended in the sense of set theory.

If a is an attribute of substrate S1 and b is an attribute of substrate S2, the attribute (a, b) of the composite substrate S1 ⊕ S2 is defined as the set of all states where S1 has attribute a and S2 has attribute b. As I stated in the main text, the principle of locality requires that if a transformation operates only on substrate S1, then only the attribute a changes, not b. It is well-know that this principle of no-action at a distance is satisfied by non-relativistic unitary quantum theory, as well as by quantum field theories.

In quantum theory, assuming for instance a two-qubit Hilbert space ${{ \mathcal H }}_{{ab}}$, we can consider the class of attributes defined as

project at (a, b) represent joint state where projection from a* onto field of *b <- scalar and scale @ *a + b  -> project at (b, *)

where Πa and Πb are given projectors defined on each qubit's Hilbert space. (In the general case this attribute may include quantum states where the subsystems are entangled.) 6 A task is the abstract specification of a physical transformation, represented as a finite set of ordered pairs of input/output attributes: T = {a1 → b1 , a2 → b2 , ⋯ , an → bn }.


**task**
key, position, interval : pressed, mouse, time since last epoch
epoch, frequency, next epoch : time, rate, action

functions = {}
memory = []

distance from center, shift from origin = integer, tuple

**data and statistics**
[degrees, average speed, scaling factor]
[project, cost of operation, complexity]
[return, power of action, net dissipated energy]

**task**
programming of input/output driver and terminal dedicated for blocking.
programming of block/release function and data requirement to write callables.
writing test code before setup step and main script outline with clean code.

for test functions, routine is needed and queue of subroutines should be programmed.
there must exist linear transition of states that are error free.
predict all possible break down scenario and prove protected override methods for each of the cases.

finally write code for switching onto another script if anything terminates.

github codespace addresses = {}

**data and statistics**
local config = {os variable : script variable}
line config = {(code object id, string formatted variable) : (remote variable name, patcher function lambda)}
remote config = {(local variable, code reference label) : (eval output string, copy of local variable)}

if local script executed without error:
    if line config transferred to codespace:
        if remote code executed without error:
            iterate over task in list possible information:
                continue to collect status from each eval and exec available
                if breaks, unroll all branches and set flag for code space config:
    if terminal: check flagged value and set status for information transfer

if information transferred:
    switch back to local path while tracing return codes from all unrolling steps.
    yield returned elements and sum of the total cost
else:
    raise ConflictExists

print collection report after closing all the gates from outside environment at main
main is successfully travelled back to home address.
current information available at home area.

**Association**
- psutil @ tools
